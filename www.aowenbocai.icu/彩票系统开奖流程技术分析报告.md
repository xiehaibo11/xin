# 彩票系统开奖完整流程深度技术分析报告

## 目录
- [1. 开奖数据获取流程](#1-开奖数据获取流程)
- [2. 开奖号码存储机制](#2-开奖号码存储机制)
- [3. 派奖计算流程](#3-派奖计算流程)
- [4. 中奖流程](#4-中奖流程)
- [5. 系统集成分析](#5-系统集成分析)
- [6. 技术架构总结](#6-技术架构总结)

---

## 1. 开奖数据获取流程

### 1.1 双模式开奖机制

系统支持两种开奖模式：

#### A. 系统开奖模式（3分钟一期彩种）
**适用彩种**: 河内五分彩、QQ分分彩、腾讯五分彩等高频彩种

**技术实现**:
```php
// API接口: /index/api/openCode
public function openCode($name = '', $is_new = 0) {
    // 1. 获取系统开奖彩种列表
    $name_array = (new Ext())->where('is_system_code', 1)->column('name');
    
    // 2. 生成开奖数据
    foreach ($name_array as $v) {
        for ($i = 0; $i < intval($lottery_setting['startIssue']); $i++) {
            $data[$now][$i] = [
                'expect' => $day . '-' . sprintf("%0" . $num_len ."d",$i + 1),
                'create_time' => date('Y-m-d H:i:s', $now_0_timestamp + $start_timestamp + $buy_timestamp * ($i + 1)),
                'code' => $this->randSystemCode(LotteryCommon::getCpType($v))
            ];
        }
        // 3. 缓存开奖数据
        Cache::set('system_code_' . $v, json_encode($data));
    }
}
```

**随机号码生成算法**:
```php
private function randSystemCode($type) {
    switch ($type) {
        case 'ssc': // 时时彩 0-9 5位数字
            for ($i = 0; $i < 5; $i++) {
                $my_array[$i] = rand(0, 9);
            }
            return implode(',', $my_array);
        case 'ks': // 快三 1-6 3位数字
            for ($i = 0; $i < 3; $i++) {
                $my_array[$i] = rand(1, 6);
            }
            return implode(',', $my_array);
    }
}
```

#### B. 外部API开奖模式
**适用彩种**: 重庆时时彩、天津时时彩等官方彩种

**数据源配置**:
```php
protected $cjUrl = [
    'ssc' => 'https://api.api68.com/QuanGuoCai/getLotteryInfoList.do?lotCode=10019',
    'tjssc' => 'https://api.api68.com/QuanGuoCai/getLotteryInfoList.do?lotCode=10041',
    'xjssc' => 'https://api.api68.com/QuanGuoCai/getLotteryInfoList.do?lotCode=10042'
];
```

**API数据处理**:
```php
public function getAwards($name) {
    $url = $this->cjUrl[$this->config[$name]];
    $response = file_get_contents($url);
    $get_code = json_decode($response, true);
    
    // 数据格式化
    $expect = $get_code['result']['data']['preDrawIssue'];
    $code = $get_code['result']['data']['preDrawCode'];
    
    return [
        'ext_name' => $name,
        'code' => $code,
        'expect' => $expect
    ];
}
```

### 1.2 Node.js定时任务系统

**系统架构**:
```javascript
// node_server/zero_task/index.js
var openCode = require("./openCode.js").createOpenCode;

// 获取彩种配置并启动定时任务
network.get(base_url + 'index/api/getSystemLotteryConfig', function (data) {
    var res = JSON.parse(data.data);
    for (let k in res) {
        var value = res[k];
        if (!value) continue;
        new openCode(value).run(); // 启动每个彩种的开奖任务
    }
});
```

**开奖任务执行**:
```javascript
// openCode.js
module.exports.createOpenCode = function(base_config) {
    this.name = base_config.name;
    this.space_time = base_config.timelong; // 间隔时间(分钟)
    
    this.run = function () {
        network.get(config.url + 'index/api/pushSystemCode?name=' + this.name, (res) => {
            if (!data.err) { // 开奖成功
                setTimeout(() => {
                    this.run();
                }, this.getNextTime(data.next_time, res.time));
            } else { // 错误重试
                setTimeout(() => {
                    this.run();
                }, 5000);
            }
        });
    }
}
```

---

## 2. 开奖号码存储机制

### 2.1 数据库表结构

**核心表**: `kr_lottery_code`
```sql
CREATE TABLE `kr_lottery_code` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `code` varchar(255) DEFAULT NULL COMMENT '开奖号码',
  `expect` char(30) DEFAULT NULL COMMENT '期号',
  `ext_name` varchar(255) DEFAULT NULL COMMENT '彩种标识',
  `create_time` timestamp DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_expect` (`expect`),
  KEY `idx_ext_name` (`ext_name`),
  KEY `idx_expect_ext` (`expect`, `ext_name`)
);
```

### 2.2 数据存储流程

**系统开奖推送**:
```php
// /index/api/pushSystemCode
public function pushSystemCode($name) {
    // 1. 验证彩种状态
    $ext_info = $ext_model->where('name', '/' . $name)->find();
    if (!$ext_info['is_system_code']) return json(['err' => 1, 'msg' => '非系统开奖']);
    
    // 2. 获取缓存的开奖数据
    $list = Cache::get('system_code_' . $name);
    $list = json_decode($list, true);
    
    // 3. 筛选需要推送的期号
    $data = [];
    foreach ($list as $v) {
        foreach ($v as $row) {
            $expect = '20' . str_replace('-', '', $row['expect']);
            if ($now_expect > $expect and $last_expect < $expect) {
                $data[] = [
                    'code' => $row['code'],
                    'expect' => $expect,
                    'ext_name' => $name
                ];
            }
        }
    }
    
    // 4. 批量插入数据库
    $res = LotteryCommon::getModel($name, 'code')->insertAll($data);
    if ($res) {
        // 5. 更新遗漏数据
        (new Award())->miss($name, $data);
        
        // 6. 发布派奖消息
        $redis = new Redis();
        $redis->pub('prize', "signature=" . $signature . "&timestamp=" . $timestamp . "&name=" . $name);
    }
}
```

### 2.3 数据验证机制

**去重验证**:
```php
// 检查重复开奖
foreach ($data as $key => $v) {
    $has_info = $code_model->where('expect', $v['expect'])->where('code', $v['code'])->find();
    if ($has_info) unset($data[$key]);
}
$data = array_unique($data, SORT_REGULAR);
```

**期号格式化**:
```php
// 不同彩种期号格式处理
if ($ext_info['expect_type']) {
    $expect = $dataNum[1]; // 直接使用期号
} else {
    $expect = (int)'20' . $dataNum[0] . sprintf("%0" . $dataNum_len . "d", intval($dataNum[1]));
}
```

---

## 3. 派奖计算流程

### 3.1 Redis消息队列机制

**消息发布**:
```php
// 开奖号码入库成功后发布派奖消息
$redis = new Redis();
$redis->pub('prize', "signature=" . $signature . "&timestamp=" . $timestamp . "&name=" . $name);
```

**消息订阅处理**:
```javascript
// Node.js订阅派奖消息
client.subscribe('prize');
client.on('message', function(channel, msg) {
    let data = msg.split('&');
    let name = data[2].split('=')[1];
    
    if (send_data.hasOwnProperty(name)) {
        send_data[name].init(msg);
    } else {
        send_data[name] = new sendPrize();
        send_data[name].init(msg);
    }
});
```

**派奖请求处理**:
```javascript
// sendPrize.js
this.run = function () {
    network.get(config.url + 'lottery/open_award/setPrize?' + this.send_data, (res) => {
        if (data.err == 2) { // 派奖失败，重试
            if (this.times < 10) {
                setTimeout(() => {
                    this.run();
                }, 1000);
                this.times++;
            }
        }
    });
}
```

### 3.2 中奖判定算法

**时时彩中奖判定**:
```php
// SscCommon.php
public function prizeCom($code, $plan, $bouns, $setting_config) {
    $code = explode(',', $code);
    
    foreach ($plan as $key => $value) {
        $playNum = $value['buy'];
        $type = explode('-', $playNum['type']);
        
        // 直选判定
        if ($zx) {
            $right = $this->zhixPrize($code, $val['num'], $type);
            $prizeNum = $right['num'];
        }
        
        // 组选判定  
        if (!$zx && $type[0] != '大小单双' && $type[0] != '龙虎' && $type[0] != '定位胆') {
            $prizeNum = $this->zxPrize($code, $val['num'], $type);
        }
        
        // 大小单双判定
        if ($type[0] == '大小单双') {
            $prizeNum = $this->dxdsPrize($code, $val['num'], $type[1]);
        }
    }
}
```

**排列三中奖算法**:
```php
// 直选中奖判定
private function zhixPrize($code, $plan, $type) {
    $plan_array = explode('|', $plan);
    $rightNum = 0;
    
    foreach ($plan_array as $key => $v) {
        $plan_num = explode(',', $v);
        $right = 0;
        
        // 逐位比较
        for ($i = 0; $i < count($plan_num); $i++) {
            if ($code[$i] == $plan_num[$i]) {
                $right++;
            }
        }
        
        // 全部位置正确才中奖
        if ($right == count($plan_num)) {
            $rightNum++;
        }
    }
    
    return ['num' => $rightNum];
}
```

### 3.3 奖金计算机制

**基础奖金计算**:
```php
// 奖金 = 基础奖金 × (100 - 返点率) / 100 × 投注倍数
$bounsNum = $gain * (100 - $bonus_base) / 100;

// 投注倍数计算
$unit_zh = [1 => 1, 2 => 10, 3 => 100, 4 => 1000];
$multiple = 1;

if (isset($plan['money'])) {
    $multiple = $plan['money'] / 2; // 投注金额除以2元
}

if (isset($plan['unit'])) {
    $multiple = 1 / $unit_zh[$plan['unit']]; // 元角分模式
}

if (isset($plan['multiple'])) {
    $multiple = $multiple * $plan['multiple']; // 追号倍数
}

return $bounsNum * $multiple;
```

**返点机制**:
```php
// 用户返点计算
$bonus_base = $sys_bonus_base; // 系统返点基数
$my_rebate = isset($user_info['rebate']['ssc']) ? $user_info['rebate']['ssc'] : 0;

if ($user_info['top_agents']) {
    $top_agents = $user_model->find($user_info['top_agents']);
    $top_rebate = isset($top_agents['rebate']['ssc']) ? $top_agents['rebate']['ssc'] : 0;
    $bonus_base = $bonus_base - $top_rebate + $my_rebate;
} else {
    $bonus_base = $bonus_base - $my_rebate;
}

if (isset($val['rebate'])) {
    if ($plan['rebate']) $bonus_base += $plan['rebate'];
}
```

---

## 4. 中奖流程

### 4.1 派奖主流程

**核心派奖方法**:
```php
// BaseCode.php - setPrize()
public function setPrize($data = []) {
    // 1. 按期号排序
    $data = $this->array_sort($data, 'expect', 'asc', 'yes');
    
    // 2. 获取相关模型
    $expectModel = LotteryCommon::getModel($this->ext_name, 'expect');
    $join = LotteryCommon::getModel($this->ext_name, 'join');
    $common = LotteryCommon::getCommon($this->ext_name);
    
    // 3. 逐期处理派奖
    foreach ($data as $top_value) {
        $expectList = (new LotteryCom())->getPrizeList($this->ext_name, $top_value['expect']);
        
        // 4. 计算中奖奖金
        $valueRes = $common->prizeCom($top_value['code'], $expectList, $setting, $setting_config);
        
        // 5. 处理每个投注记录
        foreach ($valueRes as $key => $value) {
            // 判断是否追号
            $expectBuyid = $expectModel->where('buy_id', $value['buy_id'])->select();
            $is_chase = count($expectBuyid) > 1 ? 1 : 0;
            
            // 合买派奖
            if ($value['is_join'] == 1) {
                $joinRes = $this->setJoinPrize($value, $is_chase, $expectBuyid, $settingCoin, $value['multiple']);
            }
            
            // 中奖停止追号
            if (!$value['is_join'] && $is_chase && $value['is_stop'] == 1 && $value['bouns'] > 0) {
                $chase = (new LotteryCom)->setStopChasePrize($value, $expectBuyid, $settingCoin);
                if (!empty($chase)) {
                    $expectModel->saveAll($chase);
                }
            }
            
            // 更新中奖状态
            if (!$value['is_join']) {
                $join_info = $join->where(['userid' => $value['userid'], 'buy_id' => $value['buy_id']])->find();
                
                if ($value['bouns'] > 0) {
                    $join->where(['userid' => $value['userid'], 'buy_id' => $value['buy_id']])->update([
                        'bonus' => $join_info['bonus'] + $value['bouns'],
                        'status' => 1 // 中奖
                    ]);
                } else {
                    $join->where(['userid' => $value['userid'], 'buy_id' => $value['buy_id']])->update([
                        'status' => 2 // 未中奖
                    ]);
                }
            }
        }
    }
}
```

### 4.2 资金变动处理

**中奖资金发放**:
```php
// 资金明细记录
$moneyHistory->write([
    'userid' => $value['userid'],
    'money' => $value['bouns'],
    'remark' => '中奖:' . $value['lottery_id'],
    'type' => 1 // 收入
]);

// 用户余额更新
$user_model->where('id', $value['userid'])->setInc('money', $value['bouns']);
```

**合买资金分配**:
```php
// 合买中奖资金按比例分配
foreach ($list as $value) {
    $money = $value['money']; // 参与金额
    $onePer = $money / $total_share; // 参与比例
    $now_bonus = floatval($onePer * $bouns * 100) / 100; // 当前期奖金
    $bonus = $value['bonus'] + $now_bonus; // 累加奖金
    
    // 更新参与记录
    $joinUpdate[] = [
        'id' => $value['id'],
        'bonus' => $bonus,
        'status' => 1
    ];
}
```

### 4.3 状态更新机制

**投注状态更新**:
```php
// 期号状态更新
$expectSave[$key] = [
    'id' => $value['id'],
    'status' => 2, // 已派奖
    'bonus' => $value['bouns']
];

// 投注单状态更新
$buyStatus = $value['bouns'] > 0 ? 1 : 2; // 1:中奖 2:未中奖
$buySave[$key] = [
    'id' => $value['buy_id'],
    'status' => $buyStatus
];
```

**追号停止机制**:
```php
// 中奖后停止追号
public function setStopChasePrize($value, $expectBuyid, $settingCoin) {
    $chase = [];
    foreach ($expectBuyid as $key => $val) {
        if ($val['expect'] > $value['expect'] && $val['status'] == 0) {
            // 返还未开奖期号的投注金额
            $returnMoney = ($val['multiple'] * $value['total']) / array_sum(array_column($expectBuyid, 'multiple'));
            
            $moneyHistory->write([
                'userid' => $value['userid'],
                'money' => $returnMoney * $settingCoin,
                'remark' => '中奖停追:' . $value['lottery_id']
            ]);
            
            // 标记为停止状态
            $chase[] = [
                'id' => $val['id'],
                'status' => 5 // 停止追号
            ];
        }
    }
    return $chase;
}
```

---

## 5. 系统集成分析

### 5.1 整体架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Node.js       │    │   PHP Backend   │    │   MySQL DB      │
│   定时任务系统   │    │   Web应用       │    │   数据存储      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │ HTTP请求              │ 数据库操作            │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ 开奖数据获取     │    │ 业务逻辑处理     │    │ 数据持久化      │
│ - 系统开奖      │    │ - 投注处理      │    │ - 开奖号码      │
│ - API采集       │    │ - 派奖计算      │    │ - 投注记录      │
│ - 定时推送      │    │ - 状态更新      │    │ - 用户资金      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │   Redis         │
                    │   消息队列      │
                    │ - 开奖通知      │
                    │ - 派奖触发      │
                    └─────────────────┘
```

### 5.2 消息流转机制

**开奖消息流**:
```
1. Node.js定时任务 → HTTP请求 → PHP开奖接口
2. PHP开奖接口 → 数据库存储 → Redis发布消息
3. Node.js订阅消息 → HTTP请求 → PHP派奖接口
4. PHP派奖接口 → 计算奖金 → 更新数据库
```

**技术实现**:
```php
// 消息发布
class Redis extends \think\cache\driver\Redis {
    public function pub($channel, $msg) {
        return $this->handler->publish($channel, $msg);
    }
}

// 使用示例
$redis = new Redis();
$redis->pub('prize', "signature=" . $signature . "&timestamp=" . $timestamp . "&name=" . $name);
```

### 5.3 容错机制

**重试机制**:
```javascript
// 开奖失败重试
if (data != "" && !data.err) {
    // 成功，计算下次执行时间
    setTimeout(() => {
        this.run();
    }, this.getNextTime(data.next_time, res.time));
} else {
    // 失败，5秒后重试
    setTimeout(() => {
        this.run();
    }, 5000);
}
```

**派奖重试**:
```javascript
// 派奖失败重试（最多10次）
if (data.err == 2) {
    if (this.times < 10) {
        setTimeout(() => {
            this.run();
        }, 1000);
        this.times++;
    }
}
```

**数据一致性保障**:
```php
// 数据库事务处理
try {
    Db::startTrans();
    
    // 1. 更新期号状态
    $expectModel->saveAll($expectSave);
    
    // 2. 更新投注状态  
    $buyModel->saveAll($buySave);
    
    // 3. 更新参与记录
    $join->saveAll($joinUpdate);
    
    // 4. 记录资金明细
    $moneyHis->saveAll($moneyData);
    
    Db::commit();
} catch (\Exception $e) {
    Db::rollback();
    throw $e;
}
```

---

## 6. 技术架构总结

### 6.1 核心技术栈

- **后端框架**: ThinkPHP 5.x
- **数据库**: MySQL 5.7+
- **缓存**: Redis 
- **定时任务**: Node.js + node-schedule
- **消息队列**: Redis Pub/Sub
- **HTTP客户端**: Node.js request/axios

### 6.2 性能优化策略

**数据库优化**:
- 期号和彩种联合索引
- 分表存储历史数据
- 读写分离架构

**缓存策略**:
- 开奖数据Redis缓存
- 用户投注信息缓存
- 彩种配置缓存

**并发处理**:
- Redis消息队列解耦
- 异步派奖处理
- 数据库连接池

### 6.3 安全机制

**签名验证**:
```php
$token = Config::get('baseConfig.authorization_token');
$check_signature = md5($token . $timestamp);
if ($signature != $check_signature) {
    return json(['err' => 1, 'msg' => '签名不通过']);
}
```

**数据验证**:
- 期号格式验证
- 开奖号码格式验证
- 重复数据检查
- 时间窗口验证

### 6.4 监控与日志

**关键监控点**:
- 开奖任务执行状态
- 派奖处理成功率
- 数据库性能指标
- Redis消息队列状态

**日志记录**:
- 开奖数据获取日志
- 派奖计算过程日志
- 异常错误日志
- 性能监控日志

---

## 结论

该彩票系统采用了成熟的分布式架构，通过Node.js定时任务、Redis消息队列、PHP业务处理和MySQL数据存储的组合，实现了高可用、高性能的开奖和派奖流程。系统具备良好的扩展性和容错能力，能够支持3分钟一期的高频彩种稳定运行。

**技术亮点**:
1. 双模式开奖机制适应不同彩种需求
2. Redis消息队列实现异步解耦
3. 完善的重试和容错机制
4. 灵活的奖金计算和返点系统
5. 严格的数据一致性保障

**改进建议**:
1. 增加分布式锁防止重复处理
2. 实现开奖数据的多源验证
3. 优化大并发下的数据库性能
4. 增强监控和告警机制
5. 考虑微服务架构拆分
